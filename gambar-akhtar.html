<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aplikasi Menggambar</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent body scroll */
        }
        canvas {
            background-color: #ffffff;
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
            cursor: crosshair;
            touch-action: none; /* Prevent default touch actions like scrolling */
        }
        .tool-button {
            @apply p-3 rounded-md flex items-center justify-center text-gray-700 hover:bg-blue-100 hover:text-blue-700 transition-colors duration-200;
        }
        .tool-button.active {
            @apply bg-blue-500 text-white;
        }
        /* Custom scrollbar for tool panel */
        .tool-panel::-webkit-scrollbar {
            width: 8px;
        }
        .tool-panel::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .tool-panel::-webkit-scrollbar-thumb {
            background: #888;
            border-radius: 10px;
        }
        .tool-panel::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body class="bg-gray-100 flex h-screen">

    <!-- Main Container -->
    <div class="flex flex-1 overflow-hidden">
        <!-- Sidebar for Tools -->
        <div class="tool-panel w-64 bg-white p-4 shadow-lg overflow-y-auto flex flex-col space-y-4">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Alat Menggambar</h2>

            <!-- Color Picker -->
            <div class="flex items-center space-x-2">
                <label for="colorPicker" class="text-gray-700 font-medium">Warna:</label>
                <input type="color" id="colorPicker" value="#000000" class="w-10 h-10 rounded-md border border-gray-300 cursor-pointer">
            </div>

            <!-- Brush Size Slider -->
            <div>
                <label for="brushSize" class="text-gray-700 font-medium block mb-1">Ukuran Kuas:</label>
                <input type="range" id="brushSize" min="1" max="50" value="5" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                <span id="brushSizeValue" class="text-sm text-gray-600 mt-1 block text-right">5px</span>
            </div>

            <!-- Drawing Tools -->
            <div class="grid grid-cols-2 gap-2">
                <button id="tool-pencil" class="tool-button active" title="Pensil">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z"></path></svg>
                </button>
                <button id="tool-eraser" class="tool-button" title="Penghapus">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-9H4a1 1 0 00-1 1v2a1 1 0 001 1h16a1 1 0 001-1V8a1 1 0 00-1-1z"></path></svg>
                </button>
                <button id="tool-line" class="tool-button" title="Garis">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l10-10M16 4l-10 10"></path></svg>
                </button>
                <button id="tool-rectangle" class="tool-button" title="Persegi Panjang (Garis)">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 18h16M4 6v12a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2z"></path></svg>
                </button>
                <button id="tool-filled-rectangle" class="tool-button" title="Persegi Panjang (Isi)">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 6h16M4 18h16M4 6v12a2 2 0 002 2h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2z"></path></svg>
                </button>
                <button id="tool-circle" class="tool-button" title="Lingkaran (Garis)">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"></path></svg>
                </button>
                <button id="tool-filled-circle" class="tool-button" title="Lingkaran (Isi)">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4z"></path><path d="M21 12c0 4.97-4.03 9-9 9s-9-4.03-9-9 4.03-9 9-9 9 4.03 9 9z"></path></svg>
                </button>
                <button id="tool-text" class="tool-button" title="Teks">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"></path></svg>
                </button>
                <button id="tool-fill" class="tool-button" title="Isi (Bucket)">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-2.414-2.414A1 1 0 0015.586 6H7a2 2 0 00-2 2v11a2 2 0 002 2z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 13l-3 3-3-3"></path></svg>
                </button>
                <button id="tool-eyedropper" class="tool-button" title="Pipet Warna">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.5l-4.5 4.5 9 9 4.5-4.5-9-9z"></path></svg>
                </button>

                <!-- New Tools Added Here -->
                <button id="tool-triangle" class="tool-button" title="Segitiga (Garis)">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16l-4-4m0 0l4-4m-4 4h18m-9 4v4m0-4V8m0 8h.01"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l9-5-9-5-9 5 9 5z"></path></svg>
                </button>
                <button id="tool-filled-triangle" class="tool-button" title="Segitiga (Isi)">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12 14l9-5-9-5-9 5 9 5z"></path></svg>
                </button>
                <button id="tool-arc" class="tool-button" title="Busur">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4.5l-4.5 4.5 9 9 4.5-4.5-9-9z"></path><path d="M4 12c0-4.418 3.582-8 8-8s8 3.582 8 8"></path></svg>
                </button>
                <button id="tool-rounded-rectangle" class="tool-button" title="Persegi Panjang Membulat (Garis)">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z"></path></svg>
                </button>
                <button id="tool-filled-rounded-rectangle" class="tool-button" title="Persegi Panjang Membulat (Isi)">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M4 6a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2V6z"></path></svg>
                </button>
                <button id="tool-arrow-line" class="tool-button" title="Garis Panah">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 8l4 4m0 0l-4 4m4-4H3"></path></svg>
                </button>
                <button id="tool-dashed-line" class="tool-button" title="Garis Putus-putus">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 12h.01M8 12h.01M12 12h.01M16 12h.01M20 12h.01"></path></svg>
                </button>
            </div>

            <!-- Actions -->
            <div class="grid grid-cols-2 gap-2 mt-4">
                <button id="action-undo" class="tool-button" title="Urungkan">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 14l-4-4m0 0l4-4m-4 4h11a3 3 0 013 3v1"></path></svg>
                </button>
                <button id="action-redo" class="tool-button" title="Ulangi">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10l4 4m0 0l-4 4m4-4H3a3 3 0 01-3-3v-1"></path></svg>
                </button>
                <button id="action-clear" class="tool-button col-span-2" title="Bersihkan Kanvas">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-9H4a1 1 0 00-1 1v2a1 1 0 001 1h16a1 1 0 001-1V8a1 1 0 00-1-1z"></path></svg>
                    Bersihkan
                </button>
                <button id="action-save" class="tool-button col-span-2 bg-green-500 text-white hover:bg-green-600" title="Simpan Gambar">
                    <svg class="w-6 h-6 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7H5a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-3m-1-4l-3 3m0 0l-3-3m3 3V4"></path></svg>
                    Simpan
                </button>
            </div>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 flex items-center justify-center p-8 overflow-hidden">
            <canvas id="drawingCanvas"></canvas>
        </div>
    </div>

    <!-- Custom Modal for Text Input -->
    <div id="textModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center hidden">
        <div class="bg-white p-6 rounded-lg shadow-xl w-96">
            <h3 class="text-lg font-semibold mb-4">Masukkan Teks</h3>
            <input type="text" id="textInput" class="w-full p-2 border border-gray-300 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Ketik teks di sini...">
            <div class="flex justify-end space-x-2">
                <button id="cancelText" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Batal</button>
                <button id="confirmText" class="px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600">Tambah Teks</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        // Tool buttons
        const toolButtons = document.querySelectorAll('.tool-button');
        const pencilBtn = document.getElementById('tool-pencil');
        const eraserBtn = document.getElementById('tool-eraser');
        const lineBtn = document.getElementById('tool-line');
        const rectBtn = document.getElementById('tool-rectangle');
        const filledRectBtn = document.getElementById('tool-filled-rectangle');
        const circleBtn = document.getElementById('tool-circle');
        const filledCircleBtn = document.getElementById('tool-filled-circle');
        const textBtn = document.getElementById('tool-text');
        const fillBtn = document.getElementById('tool-fill');
        const eyedropperBtn = document.getElementById('tool-eyedropper');

        // New tool buttons
        const triangleBtn = document.getElementById('tool-triangle');
        const filledTriangleBtn = document.getElementById('tool-filled-triangle');
        const arcBtn = document.getElementById('tool-arc');
        const roundedRectBtn = document.getElementById('tool-rounded-rectangle');
        const filledRoundedRectBtn = document.getElementById('tool-filled-rounded-rectangle');
        const arrowLineBtn = document.getElementById('tool-arrow-line');
        const dashedLineBtn = document.getElementById('tool-dashed-line');


        // Action buttons
        const undoBtn = document.getElementById('action-undo');
        const redoBtn = document.getElementById('action-redo');
        const clearBtn = document.getElementById('action-clear');
        const saveBtn = document.getElementById('action-save');

        // Controls
        const colorPicker = document.getElementById('colorPicker');
        const brushSizeSlider = document.getElementById('brushSize');
        const brushSizeValueSpan = document.getElementById('brushSizeValue');

        // Text modal elements
        const textModal = document.getElementById('textModal');
        const textInput = document.getElementById('textInput');
        const confirmTextBtn = document.getElementById('confirmText');
        const cancelTextBtn = document.getElementById('cancelText');

        let drawing = false;
        let currentTool = 'pencil';
        let currentColor = '#000000';
        let currentBrushSize = 5;
        let startX, startY; // For shapes and lines
        let snapshot; // To store canvas state for undo/redo
        let history = [];
        let historyIndex = -1;
        let textInputX, textInputY; // Coordinates for text tool

        // Initialize canvas size to fit parent
        function resizeCanvas() {
            // Get the computed style of the parent container to determine available space
            const canvasContainer = canvas.parentElement;
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;

            // Set canvas dimensions
            canvas.width = containerWidth * 0.9; // Use a percentage of container width
            canvas.height = containerHeight * 0.9; // Use a percentage of container height

            // Ensure canvas is not too small or too large, set min/max if necessary
            canvas.width = Math.max(300, Math.min(canvas.width, 1200));
            canvas.height = Math.max(300, Math.min(canvas.height, 800));

            // Restore image after resize
            if (history[historyIndex]) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before redrawing
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
                img.src = history[historyIndex];
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear if no history
            }
            saveState(); // Save the new state after resizing
        }

        // Save current canvas state to history
        function saveState() {
            // Remove any future states if we've undone something and are now drawing new content
            if (historyIndex < history.length - 1) {
                history = history.slice(0, historyIndex + 1);
            }
            history.push(canvas.toDataURL());
            historyIndex++;
            console.log(`State saved. History length: ${history.length}, Index: ${historyIndex}`);
        }

        // Restore canvas state from history
        function restoreState() {
            if (historyIndex >= 0) {
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
                img.src = history[historyIndex];
            } else {
                // If historyIndex is -1, clear the canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        }

        // Initial setup
        window.addEventListener('load', () => {
            resizeCanvas();
            saveState(); // Save initial blank state
            // Set initial tool and color properties for context
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor;
            ctx.lineWidth = currentBrushSize;
            brushSizeValueSpan.textContent = `${currentBrushSize}px`;
        });
        window.addEventListener('resize', resizeCanvas);

        // Event Listeners for Tools
        toolButtons.forEach(button => {
            button.addEventListener('click', () => {
                toolButtons.forEach(btn => btn.classList.remove('active'));
                button.classList.add('active');
                currentTool = button.id.replace('tool-', '');
                console.log('Current tool:', currentTool);
                // Reset cursor for eyedropper
                canvas.style.cursor = currentTool === 'eyedropper' ? 'copy' : 'crosshair';
                // Ensure context properties are updated when tool changes
                ctx.strokeStyle = currentColor;
                ctx.fillStyle = currentColor;
                ctx.lineWidth = currentBrushSize;
                // Reset line dash for new tools
                ctx.setLineDash([]);
            });
        });

        colorPicker.addEventListener('input', (e) => {
            currentColor = e.target.value;
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor;
            console.log('Color changed to:', currentColor);
        });

        brushSizeSlider.addEventListener('input', (e) => {
            currentBrushSize = parseInt(e.target.value);
            brushSizeValueSpan.textContent = `${currentBrushSize}px`;
            ctx.lineWidth = currentBrushSize;
            console.log('Brush size changed to:', currentBrushSize);
        });

        // Canvas Drawing Logic
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mousemove', draw);

        // Touch Events for Mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent scrolling
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            // Check if it's a touch event or mouse event
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            } else {
                clientX = event.clientX;
                clientY = event.clientY;
            }

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function startDrawing(e) {
            const mousePos = getMousePos(e);
            startX = mousePos.x;
            startY = mousePos.y;
            drawing = true;

            // Always update context properties before starting a new draw action
            ctx.strokeStyle = currentColor;
            ctx.fillStyle = currentColor;
            ctx.lineWidth = currentBrushSize;
            ctx.setLineDash([]); // Reset line dash for most tools

            if (currentTool === 'pencil' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(startX, startY);
            } else if (currentTool === 'text') {
                textInputX = startX;
                textInputY = startY;
                textModal.classList.remove('hidden');
                textInput.focus();
            } else if (currentTool === 'fill') {
                // Implement fill tool logic
                fillBucket(startX, startY, currentColor);
                saveState();
            } else if (currentTool === 'eyedropper') {
                const pixel = ctx.getImageData(startX, startY, 1, 1).data;
                const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
                colorPicker.value = hex;
                currentColor = hex;
                ctx.strokeStyle = currentColor; // Update context immediately
                ctx.fillStyle = currentColor;   // Update context immediately
                drawing = false; // Eyedropper is a single click action
            } else if (currentTool === 'dashed-line') {
                ctx.setLineDash([5, 5]); // Set dash pattern for dashed line
            }
            snapshot = ctx.getImageData(0, 0, canvas.width, canvas.height); // Save snapshot for shapes
        }

        function draw(e) {
            if (!drawing) return;

            const mousePos = getMousePos(e);
            const currentX = mousePos.x;
            const currentY = mousePos.y;

            // Ensure these are always up-to-date during drawing
            ctx.lineWidth = currentBrushSize;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Restore snapshot for shapes to clear previous temporary drawing
            if (currentTool !== 'pencil' && currentTool !== 'eraser') {
                ctx.putImageData(snapshot, 0, 0);
            }

            switch (currentTool) {
                case 'pencil':
                    ctx.strokeStyle = currentColor;
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    break;
                case 'eraser':
                    ctx.strokeStyle = '#ffffff'; // Eraser color is white
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    break;
                case 'line':
                    ctx.strokeStyle = currentColor;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 'rectangle':
                    ctx.strokeStyle = currentColor;
                    ctx.beginPath();
                    ctx.rect(startX, startY, currentX - startX, currentY - startY);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                case 'filled-rectangle':
                    ctx.fillStyle = currentColor;
                    ctx.beginPath();
                    ctx.rect(startX, startY, currentX - startX, currentY - startY);
                    ctx.fill();
                    ctx.closePath();
                    break;
                case 'circle':
                    ctx.strokeStyle = currentColor;
                    drawCircle(startX, startY, currentX, currentY, false);
                    break;
                case 'filled-circle':
                    ctx.fillStyle = currentColor;
                    drawCircle(startX, startY, currentX, currentY, true);
                    break;
                case 'triangle':
                    ctx.strokeStyle = currentColor;
                    drawTriangle(startX, startY, currentX, currentY, false);
                    break;
                case 'filled-triangle':
                    ctx.fillStyle = currentColor;
                    drawTriangle(startX, startY, currentX, currentY, true);
                    break;
                case 'arc':
                    ctx.strokeStyle = currentColor;
                    drawArc(startX, startY, currentX, currentY);
                    break;
                case 'rounded-rectangle':
                    ctx.strokeStyle = currentColor;
                    drawRoundedRect(startX, startY, currentX - startX, currentY - startY, 10, false); // 10px radius
                    break;
                case 'filled-rounded-rectangle':
                    ctx.fillStyle = currentColor;
                    drawRoundedRect(startX, startY, currentX - startX, currentY - startY, 10, true); // 10px radius
                    break;
                case 'arrow-line':
                    ctx.strokeStyle = currentColor;
                    drawArrowLine(startX, startY, currentX, currentY);
                    break;
                case 'dashed-line':
                    ctx.strokeStyle = currentColor;
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(currentX, currentY);
                    ctx.stroke();
                    ctx.closePath();
                    break;
                // Text, Fill, Eyedropper are handled on mousedown
            }
        }

        function stopDrawing() {
            if (!drawing) return;
            drawing = false;

            // Close path for continuous drawing tools
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                ctx.closePath();
            }
            // Reset line dash after drawing is complete for dashed line
            if (currentTool === 'dashed-line') {
                ctx.setLineDash([]);
            }

            // Save state after each completed drawing action for most tools
            if (currentTool !== 'text' && currentTool !== 'fill' && currentTool !== 'eyedropper') {
                saveState();
            }
        }

        function drawCircle(x1, y1, x2, y2, fill) {
            const radiusX = Math.abs(x2 - x1) / 2;
            const radiusY = Math.abs(y2 - y1) / 2;
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;

            ctx.beginPath();
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            if (fill) {
                ctx.fill();
            } else {
                ctx.stroke();
            }
            ctx.closePath();
        }

        function drawTriangle(x1, y1, x2, y2, fill) {
            ctx.beginPath();
            // Top point (centered horizontally between x1 and x2)
            ctx.moveTo((x1 + x2) / 2, y1);
            // Bottom-left point
            ctx.lineTo(x1, y2);
            // Bottom-right point
            ctx.lineTo(x2, y2);
            ctx.closePath(); // Connects last point to first point
            if (fill) {
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        function drawArc(x1, y1, x2, y2) {
            // Simple arc: start point, end point, and a control point for curvature
            // For simplicity, let's make it a quarter circle or half circle based on direction
            const midX = (x1 + x2) / 2;
            const midY = (y1 + y2) / 2;
            const radius = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)) / 2;

            ctx.beginPath();
            // Using arcTo for a more flexible curve based on two tangent points and a radius
            // This is a simplified example, a true interactive arc tool is more complex.
            // For now, it will draw a curve from startX,startY to currentX,currentY via a control point.
            // Let's use a quadratic Bezier curve for a simple arc feel.
            const cpX = x1 + (x2 - x1) * 0.5; // Control point x
            const cpY = y1 + (y2 - y1) * 0.5 - (y2 - y1 > 0 ? radius : -radius) * 0.5; // Control point y for curvature

            ctx.moveTo(x1, y1);
            ctx.quadraticCurveTo(cpX, cpY, x2, y2);
            ctx.stroke();
            ctx.closePath();
        }

        function drawRoundedRect(x, y, width, height, radius, fill) {
            if (width < 0) { x += width; width = -width; }
            if (height < 0) { y += height; height = -height; }
            radius = Math.min(radius, width / 2, height / 2); // Ensure radius doesn't exceed half of shortest side

            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            } else {
                ctx.stroke();
            }
        }

        function drawArrowLine(x1, y1, x2, y2) {
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // Draw arrowhead
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const headLength = currentBrushSize * 3; // Size of the arrowhead

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6), y2 - headLength * Math.sin(angle - Math.PI / 6));
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6), y2 - headLength * Math.sin(angle + Math.PI / 6));
            ctx.stroke();
            ctx.closePath();
        }


        // Undo/Redo
        undoBtn.addEventListener('click', () => {
            if (historyIndex > 0) {
                historyIndex--;
                restoreState();
            }
        });

        redoBtn.addEventListener('click', () => {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                restoreState();
            }
        });

        // Clear Canvas
        clearBtn.addEventListener('click', () => {
            // Using a custom modal instead of alert/confirm
            const modal = document.createElement('div');
            modal.className = 'fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center';
            modal.innerHTML = `
                <div class="bg-white p-6 rounded-lg shadow-xl w-80">
                    <h3 class="text-lg font-semibold mb-4">Konfirmasi</h3>
                    <p class="mb-4">Apakah Anda yakin ingin membersihkan kanvas?</p>
                    <div class="flex justify-end space-x-2">
                        <button id="cancelClear" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-md hover:bg-gray-300">Batal</button>
                        <button id="confirmClear" class="px-4 py-2 bg-red-500 text-white rounded-md hover:bg-red-600">Bersihkan</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            document.getElementById('confirmClear').addEventListener('click', () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                saveState(); // Save the cleared state
                modal.remove();
            });

            document.getElementById('cancelClear').addEventListener('click', () => {
                modal.remove();
            });
        });

        // Save Image
        saveBtn.addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = 'gambar-saya.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        });

        // Text Tool Logic
        confirmTextBtn.addEventListener('click', () => {
            const text = textInput.value;
            if (text) {
                ctx.font = `${currentBrushSize * 2}px Inter`; // Adjust font size based on brush size
                ctx.fillStyle = currentColor;
                ctx.fillText(text, textInputX, textInputY + (currentBrushSize * 2 / 2)); // Adjust Y for baseline
                saveState();
            }
            textInput.value = '';
            textModal.classList.add('hidden');
        });

        cancelTextBtn.addEventListener('click', () => {
            textInput.value = '';
            textModal.classList.add('hidden');
        });

        // Fill Bucket Tool (Simple Flood Fill)
        // Note: This is a basic implementation and can be slow/buggy on complex images.
        // For production, consider more optimized algorithms or libraries.
        function fillBucket(startX, startY, fillColor) {
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const targetColor = getPixelColor(pixels, startX, startY, canvas.width);
            const fillRGB = hexToRgb(fillColor);

            // If target color is already the fill color, do nothing
            if (targetColor[0] === fillRGB.r && targetColor[1] === fillRGB.g && targetColor[2] === fillRGB.b) {
                return;
            }

            const stack = [[startX, startY]];

            while (stack.length > 0) {
                const [x, y] = stack.pop();

                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                    continue;
                }

                const currentColorAtPixel = getPixelColor(pixels, x, y, canvas.width);

                if (currentColorAtPixel[0] === targetColor[0] &&
                    currentColorAtPixel[1] === targetColor[1] &&
                    currentColorAtPixel[2] === targetColor[2]) {

                    setPixelColor(pixels, x, y, fillRGB.r, fillRGB.g, fillRGB.b, canvas.width);

                    stack.push([x + 1, y]);
                    stack.push([x - 1, y]);
                    stack.push([x, y + 1]);
                    stack.push([x, y - 1]);
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        function getPixelColor(pixels, x, y, width) {
            const index = (y * width + x) * 4;
            return [pixels[index], pixels[index + 1], pixels[index + 2]];
        }

        function setPixelColor(pixels, x, y, r, g, b, width) {
            const index = (y * width + x) * 4;
            pixels[index] = r;
            pixels[index + 1] = g;
            pixels[index + 2] = b;
            pixels[index + 3] = 255; // Alpha
        }

        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r, g, b };
        }

        function rgbToHex(r, g, b) {
            return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
        }
    </script>
</body>
</html>
